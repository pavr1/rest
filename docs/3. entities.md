# ðŸ—„ï¸ Bar-Restaurant Application - Database Entities

## Overview
This document defines all database entities (tables) and their fields required for the bar-restaurant application, based on the requirements in `bar-rest.md`.

---

## Table of Contents

### Core Entities
1. [Tables](#1-tables) - Manage restaurant tables and their status
2. [Customers](#2-customers) - Store customer information for loyalty and promotions
3. [Orders](#3-orders) - Manage customer orders
4. [Order Items](#4-order-items) - Individual items within an order with status tracking
5. [Menu Items](#5-menu-items) - Menu items (food and drinks)
6. [Menu Categories](#6-menu-categories) - Organize menu items into categories
7. [Stock Items](#7-stock-items) - Store all items that can be purchased and tracked in inventory
8. [Stock Item Categories](#8-stock-item-categories) - Organize stock items into categories
9. [Menu Item Stock Items](#9-menu-item-stock-items) - Link menu items to stock items with quantities
10. [Suppliers](#10-suppliers) - Track stock item suppliers
11. [Invoices (Purchase Invoices)](#11-invoices-purchase-invoices) - Track purchase invoices from suppliers
12. [Invoice Details](#12-invoice-details) - Line items for purchase invoices
13. [Existences](#13-existences) - Track stock item inventory stock and cost information
14. [Customer Favorites](#14-customer-favorites) - Store customer favorite menu items

### Business Logic Entities
15. [Payments](#15-payments) - Track payment transactions
16. [Invoices (Customer Invoices/Receipts)](#16-invoices-customer-invoicesreceipts) - Generate invoices for transactions
17. [Staff](#17-staff) - Staff accounts and authentication
18. [Request Notifications](#18-request-notifications) - Store all customer requests (payment, assistance, etc.)
19. [Karaoke Song Requests](#19-karaoke-song-requests) - Manage karaoke song requests
20. [Karaoke Song Library](#20-karaoke-song-library) - Available songs in karaoke library
21. [Loyalty Points Transactions](#21-loyalty-points-transactions) - Track loyalty points earned and spent
22. [Table Sessions](#22-table-sessions) - Track table sessions (when table is occupied)

### Advanced Features Entities (Future)
23. [Reservations](#23-reservations) - Table reservations
24. [Promotions](#24-promotions) - Promotional campaigns
25. [Reviews](#25-reviews) - Customer reviews and ratings

---

## Core Entities

### 1. Tables
**Purpose**: Manage restaurant tables and their status

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique table identifier |
| table_number | VARCHAR(10) | UNIQUE, NOT NULL | Table number/identifier |
| capacity | INTEGER | NOT NULL, DEFAULT 4 | Maximum number of people |
| status | ENUM | NOT NULL, DEFAULT 'available' | Table status: available, occupied, reserved |
| floor_plan_position | JSON | NULLABLE | Position coordinates for floor plan visualization |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Status Values**: `available`, `occupied`, `reserved`

**Notes**:
- QR codes are generated dynamically: `{ordering_link}/{table_number}` for orders, `{karaoke_link}/{table_number}` for karaoke
- QR codes are not stored in database - generated in real-time or via third-party service
- Table number is used to generate QR codes on-the-fly

---

### 2. Customers
**Purpose**: Store customer information for loyalty and promotions

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique customer identifier |
| customer_id | VARCHAR(50) | UNIQUE, NOT NULL | CÃ©dula/identification number |
| name | VARCHAR(255) | NOT NULL | Customer full name (first name + last name) |
| phone | VARCHAR(20) | NOT NULL | Phone number |
| email | VARCHAR(255) | NULLABLE | Email address (optional) |
| date_of_birth | DATE | NULLABLE | Date of birth (for birthday promotions) |
| loyalty_points | INTEGER | DEFAULT 0 | Current loyalty points balance |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | First visit timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes**:
- **Customer record is only created when customer opts into loyalty program**
- Flow: Customer scans QR â†’ app asks FIRST if they want loyalty program
  - **If YES**: Customer provides ID, Name (first name + last name), Phone (all required), Email (optional), Date of Birth (optional) â†’ customer record created
  and Customer ID stored in a cookie (non-expired), so next time logged the system will recognize that id and create orders under it.
  - **If NO**: Customer enters simple name only â†’ NO customer record created (order uses only person_name)
- All fields except email and date_of_birth are REQUIRED when record exists (ID, Name, Phone are NOT NULL)
- Name field stores full name (first name + last name) for loyalty program members
- `date_of_birth` is optional but enables birthday promotions (if provided, customer becomes eligible for birthday promotions)
- Customer can be identified by `customer_id` or `phone` for lookup

---

### 3. Orders
**Purpose**: Manage customer orders

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique order identifier |
| table_id | UUID | FOREIGN KEY â†’ tables.id, NOT NULL | Table where order was placed |
| customer_id | UUID | FOREIGN KEY â†’ customers.id, NULLABLE | Customer record (only if customer opted into loyalty program) |
| customer_name | VARCHAR(255) | CONDITIONAL NOT NULL | Customer name (see notes for conditional requirement) |
| status | ENUM | NOT NULL, DEFAULT 'created' | Order status: created, preparing, paid, cancelled |
| payment_status | ENUM | NOT NULL, DEFAULT 'unpaid' | Payment status: unpaid, requested, paid, refunded |
| payment_requested_at | TIMESTAMP | NULLABLE | When customer requested payment |
| paid_at | TIMESTAMP | NULLABLE | When order was paid |
| promotion_id | UUID | FOREIGN KEY â†’ promotions.id, NULLABLE | Promotion applied to this order |
| total_amount | DECIMAL(10,2) | DEFAULT 0.00 | Total order amount |
| promotion_discount_amount | DECIMAL(10,2) | DEFAULT 0.00 | Discount amount from promotion (if applied) |
| tax_amount | DECIMAL(10,2) | DEFAULT 0.00 | Tax amount |
| service_charge | DECIMAL(10,2) | DEFAULT 0.00 | Service charge amount |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Order creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |
| confirmed_at | TIMESTAMP | NULLABLE | When customer confirmed order |

**Status Values**: `created`, `preparing`, `paid`, `cancelled`
**Payment Status Values**: `unpaid`, `requested`, `paid`, `refunded`

**Notes**:
- **Customer Name Logic**:
  - If `customer_id` is NOT NULL: `customer_name` is populated from customer record (name field)
  - If `customer_id` is NULL: `customer_name` is REQUIRED (entered by customer, simple name)
- Multiple orders can exist for the same table simultaneously
- Each order is independent and can be paid separately
- `customer_id` is nullable - only set if customer opted into loyalty program
- Flow: App asks FIRST if customer wants loyalty program â†’ if YES, customer provides full info (ID, first+last name, phone) and record created; if NO, customer enters simple name only
- **Status Rules**:
  - `created`: Order has been created and confirmed
  - `preparing`: Order has started being worked on (at least one item status is "Preparing" or beyond)
  - `paid`: Order has been paid
  - `cancelled`: Order was cancelled
  - **If status is `cancelled`, payment_status remains `unpaid`** (cancelled orders are not paid)
- **Promotion Logic**:
  - **Time-based promotions** (`happy_hour`, `daily_deal`, `seasonal`): If order is created within promotion's time window (`start_date` to `end_date`), automatically apply `promotion_id` to order
  - **Customer-specific promotions** (`birthday`, `loyalty_reward`): 
    - For `loyalty_reward`: Check if customer has enough `loyalty_points` (must have â‰¥ `promotion.points_required`)
    - If eligible: Create negative loyalty points transaction (mark points as "used"), apply `promotion_id` to order, calculate `promotion_discount_amount`
    - For `birthday`: Check if customer's birthday matches current date (implementation detail)
  - Only one promotion can be applied per order
  - `promotion_discount_amount` stores the calculated discount based on `discount_type` and `discount_value`

---

### 4. Order Items
**Purpose**: Individual items within an order with status tracking

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique order item identifier |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NOT NULL | Parent order |
| menu_item_id | UUID | FOREIGN KEY â†’ menu_items.id, NOT NULL | Menu item reference |
| quantity | INTEGER | NOT NULL, DEFAULT 1 | Quantity ordered |
| unit_price | DECIMAL(10,2) | NOT NULL | Price at time of order |
| subtotal | DECIMAL(10,2) | NOT NULL | Quantity Ã— unit_price |
| status | ENUM | NOT NULL, DEFAULT 'requested' | Item status: requested, preparing, ready, delivered, lost |
| order_type | ENUM | NULLABLE | "For Here" or "To Go" (food items only) |
| special_instructions | TEXT | NULLABLE | Special instructions/comments |
| lost_reason | VARCHAR(255) | NULLABLE | Reason for loss (if status = lost) |
| fault_type | ENUM | NULLABLE | Fault type: restaurant_fault, customer_fault (if lost) |
| lost_cost | DECIMAL(10,2) | NULLABLE | Cost lost (if restaurant fault) - calculated proportionally based on quantity lost |
| requested_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | When item was requested |
| preparing_at | TIMESTAMP | NULLABLE | When item status changed to preparing |
| ready_at | TIMESTAMP | NULLABLE | When item status changed to ready |
| delivered_at | TIMESTAMP | NULLABLE | When item status changed to delivered |
| lost_at | TIMESTAMP | NULLABLE | When item status changed to lost |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Status Values**: `requested`, `preparing`, `ready`, `delivered`, `lost`
**Order Type Values**: `for_here`, `to_go` (NULL for drinks)
**Fault Type Values**: `restaurant_fault`, `customer_fault`

**Notes**:
- Each item has individual status tracking
- Time tracking for each status transition
- Lost items require reason and fault determination
- Order type only applies to food items (drinks don't have this)
- **Lost Cost Calculation**: If an order item has `quantity > 1` but only some dishes are lost, `lost_cost` is calculated proportionally:
  - Example: If quantity = 2, unit_price = $10, subtotal = $20, but only 1 dish is lost â†’ `lost_cost` = $10 (half the subtotal, or unit_price Ã— quantity_lost)
  - Only applies when `fault_type = 'restaurant_fault'`

---

### 5. Menu Items
**Purpose**: Menu items (food and drinks)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique menu item identifier |
| name | VARCHAR(255) | NOT NULL | Item name |
| description | TEXT | NULLABLE | Item description |
| category_id | UUID | FOREIGN KEY â†’ menu_categories.id, NOT NULL | Menu category |
| price | DECIMAL(10,2) | NOT NULL | Selling price (price customer pays) |
| item_cost | DECIMAL(10,2) | NULLABLE | Item cost (cost to buy/make the item) |
| happy_hour_price | DECIMAL(10,2) | NULLABLE | Happy hour price |
| image_url | VARCHAR(500) | NULLABLE | Item image URL |
| is_available | BOOLEAN | NOT NULL, DEFAULT true | Availability flag (kitchen staff can toggle) |
| item_type | ENUM | NOT NULL | Item type: kitchen, bar |
| menu_types | JSON | NOT NULL | Array of menu types: ["breakfast"], ["lunch"], ["dinner"], or combinations |
| dietary_tags | JSON | NULLABLE | Array of dietary tags: ["vegetarian", "vegan", "gluten-free"] |
| allergens | JSON | NULLABLE | Array of allergens: ["nuts", "dairy", "eggs"] |
| is_alcoholic | BOOLEAN | DEFAULT false | Whether item contains alcohol |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Item Type Values**: `kitchen`, `bar`
**Menu Types**: Array of strings: `["breakfast"]`, `["lunch"]`, `["dinner"]`, or combinations like `["lunch", "dinner"]`

**Notes**:
- `price` is the selling price (what customer pays)
- `item_cost` is the cost to buy/make the item:
  - **ALL menu items**: `item_cost` is calculated from stock items using existences:
    - For each stock item in `menu_item_stock_items`, get the most recent `existence.cost_per_unit`
    - `item_cost` = SUM(existence.cost_per_unit Ã— menu_item_stock_items.quantity) for all stock items
  - Examples:
    - Food item (burger): Uses multiple stock items (bun, patty, lettuce, etc.) â†’ cost calculated from all
    - Bottled beer: Uses single stock item ("Bottled Beer") â†’ cost calculated from that stock item's existence
- Income (profit) = `price` - `item_cost`
- `is_available` can be toggled by kitchen staff in real-time
- `menu_types` determines which time-based menu(s) the item appears in
- `order_type` (For Here/To Go) only applies to food items (kitchen items)
- Stock items are managed through the `menu_item_stock_items` junction table (see below)
- Stock item costs come from `existences` table (most recent purchase cost)

---

### 6. Menu Categories
**Purpose**: Organize menu items into categories

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique category identifier |
| name | VARCHAR(255) | NOT NULL, UNIQUE | Category name (Food, Drinks, Appetizers, etc.) |
| display_order | INTEGER | NOT NULL, DEFAULT 0 | Order for display in menu |
| description | TEXT | NULLABLE | Category description |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

---

### 7. Stock Items
**Purpose**: Store all items that can be purchased and tracked in inventory (raw ingredients, bottled drinks, finished products, etc.)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique stock item identifier |
| name | VARCHAR(255) | NOT NULL, UNIQUE | Stock item name |
| unit | VARCHAR(50) | NOT NULL | Unit of measurement (gallon, bottle, unit, liter, kg, etc.) |
| description | TEXT | NULLABLE | Stock item description |
| stock_item_category_id | UUID | FOREIGN KEY â†’ stock_item_categories.id, NULLABLE | Stock item category |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Unit Values**: Examples: `gallon`, `bottle`, `unit`, `liter`, `kg`, `gram`, `ounce`, `pound`, `bag`, `box`, etc.

**Notes**:
- **ALL items are stock items**: This includes raw ingredients (flour, tomatoes), finished products (bottled beer, canned soda), and everything in between
- Every stock item can have existences (inventory records) to track stock levels and costs
- Unit field specifies how the stock item is measured (e.g., "gallon" for liquids, "bottle" for bottled items, "unit" for individual items)
- Stock items are linked to menu items through `menu_item_stock_items` table
- Examples: "Bottled Beer", "Flour", "Tomatoes", "Canned Soda", "Ice Cream Base", etc.

---

### 8. Stock Item Categories
**Purpose**: Organize stock items into categories

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique category identifier |
| name | VARCHAR(255) | NOT NULL, UNIQUE | Category name (e.g., "Dairy", "Meat", "Vegetables", "Beverages", "Spices", "Finished Products") |
| description | TEXT | NULLABLE | Category description |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

---

### 9. Menu Item Stock Items
**Purpose**: Link menu items to stock items with quantities (for cost calculation and inventory tracking)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique menu item stock item identifier |
| menu_item_id | UUID | FOREIGN KEY â†’ menu_items.id, NOT NULL, ON DELETE CASCADE | Menu item reference |
| stock_item_id | UUID | FOREIGN KEY â†’ stock_items.id, NOT NULL, ON DELETE CASCADE | Stock item reference |
| quantity | DECIMAL(10,2) | NOT NULL, CHECK (quantity > 0) | Quantity of stock item needed |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |
| UNIQUE(menu_item_id, stock_item_id) | | | Prevent duplicate stock item entries per menu item |

**Notes**:
- This table links menu items to their stock items with quantities
- **ALL menu items use stock items**: 
  - Food items and crafted drinks: Use multiple stock items (e.g., flour, tomatoes, spices)
  - Simple drinks (bottled/pre-made): Use a single stock item (e.g., "Bottled Beer")
- Used to calculate `item_cost` for ALL menu items:
  - For each stock item, get the most recent `existence.cost_per_unit` from the `existences` table
  - `item_cost` = SUM(existence.cost_per_unit Ã— menu_item_stock_items.quantity) for all stock items
- Quantity is stored as DECIMAL to support fractional amounts (e.g., 0.5 liters, 1.5 units)
- When menu items are prepared, stock item usage should decrement `units_available` in the `existences` table
- Example: "Bottled Beer" menu item â†’ links to "Bottled Beer" stock item with quantity = 1

---

### 10. Suppliers
**Purpose**: Track stock item suppliers

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique supplier identifier |
| name | VARCHAR(255) | NOT NULL, UNIQUE | Supplier name |
| contact_name | VARCHAR(255) | NULLABLE | Contact person name |
| phone | VARCHAR(20) | NULLABLE | Phone number |
| email | VARCHAR(255) | NULLABLE | Email address |
| address | TEXT | NULLABLE | Supplier address |
| notes | TEXT | NULLABLE | Additional notes |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

---

### 11. Invoices (Purchase Invoices)
**Purpose**: Track purchase invoices from suppliers

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique invoice identifier |
| invoice_number | VARCHAR(100) | NOT NULL, UNIQUE | Invoice number from supplier |
| supplier_id | UUID | FOREIGN KEY â†’ suppliers.id, NULLABLE | Supplier reference |
| transaction_date | DATE | NOT NULL | Invoice date |
| total_amount | DECIMAL(12,2) | NULLABLE | Total invoice amount |
| image_url | VARCHAR(500) | NULLABLE | Scanned invoice image URL |
| notes | TEXT | NULLABLE | Additional notes |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes**:
- Purchase invoices track stock item purchases from suppliers
- Used to create existences (inventory records) for stock items

---

### 12. Invoice Details
**Purpose**: Line items for purchase invoices (ingredients purchased)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique invoice detail identifier |
| invoice_id | UUID | FOREIGN KEY â†’ invoices.id, NOT NULL, ON DELETE CASCADE | Parent invoice |
| stock_item_id | UUID | FOREIGN KEY â†’ stock_items.id, NULLABLE | Stock item reference |
| detail | TEXT | NOT NULL | Stock item description/name |
| count | DECIMAL(10,2) | NOT NULL, CHECK (count > 0) | Quantity purchased |
| unit_type | VARCHAR(50) | NOT NULL | Unit type (gallon, bottle, unit, liter, kg, etc.) |
| price | DECIMAL(10,2) | NOT NULL, CHECK (price > 0) | Price per unit |
| items_per_unit | INTEGER | NOT NULL, DEFAULT 1, CHECK (items_per_unit > 0) | Items per unit (e.g., 31 ice cream balls per gallon) |
| total | DECIMAL(12,2) | GENERATED ALWAYS AS (count Ã— price) STORED | Total cost (count Ã— price) |
| expiration_date | DATE | NULLABLE | Expiration date (if applicable) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes**:
- Invoice details represent individual stock items purchased in an invoice
- Used to create existences (inventory records) when stock items are received
- `items_per_unit` allows tracking of sub-units (e.g., 31 ice cream balls per gallon)
- Examples: Invoice detail for "Bottled Beer" stock item with count=24, unit_type="bottle"

---

### 13. Existences
**Purpose**: Track stock item inventory stock and cost information

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique existence identifier |
| existence_reference_code | INTEGER | UNIQUE, NOT NULL | Auto-incrementing reference code |
| stock_item_id | UUID | FOREIGN KEY â†’ stock_items.id, NOT NULL, ON DELETE CASCADE | Stock item reference |
| invoice_detail_id | UUID | FOREIGN KEY â†’ invoice_details.id, NOT NULL | Invoice detail reference (source of purchase) |
| units_purchased | DECIMAL(10,2) | NOT NULL | Units purchased (from invoice) |
| units_available | DECIMAL(10,2) | NOT NULL | Units currently available in stock |
| unit_type | VARCHAR(50) | NOT NULL | Unit type (gallon, bottle, unit, liter, kg, etc.) |
| items_per_unit | INTEGER | NOT NULL, CHECK (items_per_unit > 0) | Items per unit (e.g., 31 ice cream balls per gallon) |
| cost_per_item | DECIMAL(10,2) | GENERATED ALWAYS AS (cost_per_unit / items_per_unit) STORED | Cost per individual item |
| cost_per_unit | DECIMAL(10,2) | NOT NULL | Cost per unit (from invoice) |
| total_purchase_cost | DECIMAL(12,2) | GENERATED ALWAYS AS (units_purchased Ã— cost_per_unit) STORED | Total purchase cost |
| remaining_value | DECIMAL(12,2) | GENERATED ALWAYS AS (units_available Ã— cost_per_unit) STORED | Current inventory value |
| expiration_date | DATE | NULLABLE | Expiration date (if applicable) |
| income_margin_percentage | DECIMAL(5,2) | DEFAULT 30.00 | Income margin percentage (for pricing calculations) |
| income_margin_amount | DECIMAL(10,2) | DEFAULT 0.00 | Income margin amount (calculated) |
| minimum_price | DECIMAL(10,2) | DEFAULT 0.00 | Minimum acceptable price for income |
| maximum_price | DECIMAL(10,2) | NULLABLE | Maximum price ceiling |
| final_price | DECIMAL(10,2) | NULLABLE | User-editable final price (must be between minimum and maximum) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes**:
- Existences track inventory stock for **ALL stock items** (raw ingredients, bottled drinks, finished products, etc.)
- Each existence represents a purchase batch from an invoice
- `units_available` decreases as stock items are used in menu items
- `cost_per_unit` is used to calculate `item_cost` for menu items:
  - When calculating menu item cost, use the most recent existence's `cost_per_unit` for each stock item
- `remaining_value` tracks current inventory value (units_available Ã— cost_per_unit)
- `items_per_unit` allows tracking sub-units (e.g., if a gallon contains 31 ice cream balls)
- When stock items are used, `units_available` is decremented (FIFO or LIFO strategy can be applied)
- Expiration dates help manage inventory rotation
- Examples: Existence for "Bottled Beer" stock item tracks how many bottles are in stock and their cost

---

### 14. Customer Favorites
**Purpose**: Store customer favorite menu items

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique favorite identifier |
| customer_id | UUID | FOREIGN KEY â†’ customers.id, NOT NULL | Customer reference |
| menu_item_id | UUID | FOREIGN KEY â†’ menu_items.id, NOT NULL | Menu item reference |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | When item was favorited |

**Notes**:
- Requires customer to have provided ID/phone (customer_id must exist)
- Favorites persist across visits

---

### 15. Payments
**Purpose**: Track payment transactions

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique payment identifier |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NOT NULL | Order being paid |
| amount | DECIMAL(10,2) | NOT NULL | Payment amount |
| payment_method | ENUM | NOT NULL | Payment method used |
| payment_status | ENUM | NOT NULL, DEFAULT 'pending' | Payment status |
| exact_change_amount | DECIMAL(10,2) | NULLABLE | Exact change amount (for cash payments) |
| cash_amount_provided | DECIMAL(10,2) | NULLABLE | Cash amount customer provided (for exact change calculation) |
| tip_amount | DECIMAL(10,2) | DEFAULT 0.00 | Tip amount |
| processed_by_staff_id | UUID | FOREIGN KEY â†’ staff.id, NULLABLE | Staff member who processed payment |
| transaction_id | VARCHAR(255) | NULLABLE | External transaction ID (for card/digital payments) |
| processed_at | TIMESTAMP | NULLABLE | When payment was processed |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Payment request timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Payment Method Values**: `cash`, `credit_card`, `debit_card`, `apple_pay`, `google_pay`
**Payment Status Values**: `pending`, `processing`, `completed`, `failed`, `refunded`

**Notes**:
- All payments are waiter-assisted
- Cash payments require exact change calculation

---

### 16. Invoices (Customer Invoices/Receipts)
**Purpose**: Generate invoices for transactions (Costa Rica compliance)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique invoice identifier |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NOT NULL | Related order |
| payment_id | UUID | FOREIGN KEY â†’ payments.id, NULLABLE | Related payment |
| invoice_number | VARCHAR(50) | UNIQUE, NOT NULL | Sequential invoice number |
| invoice_type | ENUM | NOT NULL | Invoice type: sales, credit_note |
| customer_name | VARCHAR(255) | NOT NULL | Customer name |
| customer_tax_id | VARCHAR(50) | NULLABLE | Customer tax ID (CÃ©dula) |
| subtotal | DECIMAL(10,2) | NOT NULL | Subtotal before taxes |
| tax_amount | DECIMAL(10,2) | NOT NULL | Tax amount |
| service_charge | DECIMAL(10,2) | DEFAULT 0.00 | Service charge |
| total_amount | DECIMAL(10,2) | NOT NULL | Total amount |
| payment_method | VARCHAR(50) | NOT NULL | Payment method used |
| xml_data | TEXT | NULLABLE | XML invoice data (for Costa Rica Factura ElectrÃ³nica) |
| digital_signature | TEXT | NULLABLE | Digital signature (if required) |
| status | ENUM | NOT NULL, DEFAULT 'draft' | Invoice status: draft, generated, sent, cancelled |
| generated_at | TIMESTAMP | NULLABLE | When invoice was generated |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Invoice Type Values**: `sales`, `credit_note`
**Status Values**: `draft`, `generated`, `sent`, `cancelled`

**Notes**:
- Invoice generation requires research (likely when staff requests)
- Costa Rica compliance requirements need investigation

---

### 17. Staff
**Purpose**: Staff accounts and authentication

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique staff identifier |
| username | VARCHAR(100) | UNIQUE, NOT NULL | Username for login |
| email | VARCHAR(255) | UNIQUE, NULLABLE | Staff email |
| password_hash | VARCHAR(255) | NOT NULL | Hashed password |
| first_name | VARCHAR(255) | NOT NULL | First name |
| last_name | VARCHAR(255) | NOT NULL | Last name |
| role | ENUM | NOT NULL | Staff role |
| is_active | BOOLEAN | NOT NULL, DEFAULT true | Whether staff member is active |
| last_login_at | TIMESTAMP | NULLABLE | Last login timestamp |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Role Values**: `waiter`, `bartender`, `chef`, `manager`, `admin`, `dj_karaoke_operator`

---

### 18. Request Notifications
**Purpose**: Store all customer requests (payment, assistance, etc.)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique notification identifier |
| request_type | ENUM | NOT NULL | Type of request |
| table_id | UUID | FOREIGN KEY â†’ tables.id, NOT NULL | Table making request |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NULLABLE | Related order (if applicable) |
| customer_name | VARCHAR(255) | NULLABLE | Customer name (if applicable) |
| message | TEXT | NULLABLE | Additional message/details |
| status | ENUM | NOT NULL, DEFAULT 'pending' | Request status |
| handled_by_staff_id | UUID | FOREIGN KEY â†’ staff.id, NULLABLE | Staff member handling request |
| handled_at | TIMESTAMP | NULLABLE | When request was handled |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Request timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Request Type Values**: `payment`, `assistance`, `refill`, `issue_report`, `special_request`
**Status Values**: `pending`, `in_progress`, `completed`, `cancelled`

**Notes**:
- All requests stored in FIFO queue
- UI retrieves from this table to display notifications

---

### 19. Karaoke Song Requests
**Purpose**: Manage karaoke song requests

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique song request identifier |
| table_id | UUID | FOREIGN KEY â†’ tables.id, NOT NULL | Table requesting song |
| customer_name | VARCHAR(255) | NOT NULL | Customer name (no ID/phone stored) |
| song_title | VARCHAR(255) | NOT NULL | Song title |
| artist_name | VARCHAR(255) | NOT NULL | Artist name |
| status | ENUM | NOT NULL, DEFAULT 'queued' | Song status |
| position_in_queue | INTEGER | NOT NULL | Position in FIFO queue |
| skip_reason | TEXT | NULLABLE | Reason if song was skipped |
| skipped_by_staff_id | UUID | FOREIGN KEY â†’ staff.id, NULLABLE | Staff who skipped song |
| started_at | TIMESTAMP | NULLABLE | When song started playing |
| completed_at | TIMESTAMP | NULLABLE | When song finished |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Request timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Status Values**: `queued`, `playing`, `completed`, `skipped`, `removed`

**Notes**:
- Queue is FIFO (first in, first out) - cannot be reordered
- No customer data persistence (name only, not linked to customers table)

---

### 20. Karaoke Song Library
**Purpose**: Available songs in karaoke library

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique song identifier |
| song_title | VARCHAR(255) | NOT NULL | Song title |
| artist_name | VARCHAR(255) | NOT NULL | Artist name |
| duration_estimate | INTEGER | NULLABLE | Estimated duration in seconds |
| is_available | BOOLEAN | NOT NULL, DEFAULT true | Whether song is available |
| popularity_count | INTEGER | DEFAULT 0 | Number of times requested |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Notes**:
- Used for pre-populating song names and artists (if feasible)

---

### 21. Loyalty Points Transactions
**Purpose**: Track loyalty points earned and spent

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique transaction identifier |
| customer_id | UUID | FOREIGN KEY â†’ customers.id, NOT NULL | Customer earning/spending points |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NULLABLE | Related order (if points from purchase) |
| transaction_type | ENUM | NOT NULL | Transaction type |
| points | INTEGER | NOT NULL | Points amount (positive for earned, negative for spent) |
| description | VARCHAR(255) | NULLABLE | Transaction description |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Transaction timestamp |

**Transaction Type Values**: `earned`, `spent`, `expired`, `bonus`, `referral`

**Notes**:
- Points accumulate based on purchases (`earned` transactions)
- Points can be spent on rewards/discounts (`spent` transactions)
- When a customer uses a `loyalty_reward` promotion:
  - A `spent` transaction is created with `points` = negative value (e.g., -100)
  - `order_id` links to the order where promotion was applied
  - Customer's `loyalty_points` balance is decremented accordingly

---

### 22. Table Sessions
**Purpose**: Track table sessions (when table is occupied)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique session identifier |
| table_id | UUID | FOREIGN KEY â†’ tables.id, NOT NULL | Table for this session |
| started_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Session start time |
| ended_at | TIMESTAMP | NULLABLE | Session end time (when staff clears session) |
| cleared_by_staff_id | UUID | FOREIGN KEY â†’ staff.id, NULLABLE | Staff member who cleared session |
| status | ENUM | NOT NULL, DEFAULT 'active' | Session status |

**Status Values**: `active`, `closed`

**Notes**:
- Session ends when staff clears it after all orders are paid
- Prevents new orders until session is cleared

---

## Advanced Features Entities (Future)

### 23. Reservations
**Purpose**: Table reservations (future feature)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique reservation identifier |
| table_id | UUID | FOREIGN KEY â†’ tables.id, NOT NULL | Reserved table |
| customer_id | UUID | FOREIGN KEY â†’ customers.id, NULLABLE | Customer (if known) |
| customer_name | VARCHAR(255) | NOT NULL | Customer name |
| customer_phone | VARCHAR(20) | NOT NULL | Customer phone |
| reservation_date | DATE | NOT NULL | Reservation date |
| reservation_time | TIME | NOT NULL | Reservation time |
| party_size | INTEGER | NOT NULL | Number of people |
| status | ENUM | NOT NULL, DEFAULT 'confirmed' | Reservation status |
| special_requests | TEXT | NULLABLE | Special requests/preferences |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Status Values**: `confirmed`, `cancelled`, `completed`, `no_show`

---

### 24. Promotions
**Purpose**: Promotional campaigns (future feature)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique promotion identifier |
| name | VARCHAR(255) | NOT NULL | Promotion name |
| description | TEXT | NULLABLE | Promotion description |
| promotion_type | ENUM | NOT NULL | Promotion type: happy_hour, daily_deal, seasonal, birthday, loyalty_reward |
| discount_type | ENUM | NOT NULL | Discount type: percentage, fixed_amount |
| discount_value | DECIMAL(10,2) | NOT NULL | Discount value |
| points_required | INTEGER | NULLABLE | Points required for loyalty_reward promotions (only for promotion_type = 'loyalty_reward') |
| recurrence_type | ENUM | NOT NULL, DEFAULT 'none' | Recurrence pattern: none, daily, weekly, monthly |
| start_date | DATE | NOT NULL | Promotion start date (first occurrence or single date) |
| end_date | DATE | NULLABLE | Promotion end date (NULL = never ends, continues indefinitely) |
| from_time | TIME | NOT NULL | Start time within day (e.g., 15:00 for 3pm) |
| to_time | TIME | NOT NULL | End time within day (e.g., 16:00 for 4pm) |
| days_of_week | JSON | NULLABLE | Days of week for weekly recurrence: ["monday", "friday"] or ["friday"] (only for recurrence_type = 'weekly') |
| is_active | BOOLEAN | NOT NULL, DEFAULT true | Whether promotion is active |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Promotion Type Values**: `happy_hour`, `daily_deal`, `seasonal`, `birthday`, `loyalty_reward`
**Discount Type Values**: `percentage`, `fixed_amount`
**Recurrence Type Values**: `none`, `daily`, `weekly`, `monthly`

**Notes**:
- **Recurrence Patterns**:
  - `none`: Single occurrence promotion (runs from `start_date` to `end_date`, or indefinitely if `end_date` is NULL)
  - `daily`: Repeats every day from `start_date` to `end_date` (or indefinitely), between `from_time` and `to_time`
  - `weekly`: Repeats on specified days of week (`days_of_week` JSON array) from `start_date` to `end_date` (or indefinitely), between `from_time` and `to_time`
    - Example: `days_of_week: ["friday"]` for "Every Friday from 3pm to 4pm"
    - Example: `days_of_week: ["monday", "wednesday", "friday"]` for "Every Monday, Wednesday, Friday"
  - `monthly`: Repeats on the same day of month each month (e.g., 15th of every month)
- **Time Windows**:
  - `from_time` and `to_time` are ALWAYS required (NOT NULL)
  - Defines the time window within each day when the promotion is active
  - Example: Happy hour every Friday 3pm-4pm requires `from_time='15:00'` and `to_time='16:00'`
- **End Date**:
  - `end_date` can be NULL for promotions that never end (run indefinitely)
  - If `end_date` is set, promotion stops recurring after that date
- **Promotion Application Logic**:
  - **Time-based promotions** (`happy_hour`, `daily_deal`, `seasonal`): Apply to ALL orders created within promotion's active time window (checks `start_date`/`end_date`, `from_time`/`to_time`, and `days_of_week` if weekly)
  - **Customer-specific promotions**:
    - `loyalty_reward`: Requires customer to have `loyalty_points` â‰¥ `points_required`. When applied, points are deducted (negative transaction in `loyalty_points_transactions`)
    - `birthday`: Requires customer's birthday to match current date (customer eligibility check needed)
  - Promotions are applied at order creation time
  - Only one promotion can be applied per order
  - `points_required` is only used for `promotion_type = 'loyalty_reward'` (NULL for other types)
- **Examples**:
  - Happy Hour every Friday 3pm-4pm: `recurrence_type='weekly'`, `days_of_week=["friday"]`, `from_time='15:00'`, `to_time='16:00'`, `start_date='2024-01-01'`, `end_date=NULL` (never ends)
  - Daily deal for one month: `recurrence_type='daily'`, `start_date='2024-01-01'`, `end_date='2024-01-31'`, `from_time='12:00'`, `to_time='14:00'`
  - One-time seasonal promotion: `recurrence_type='none'`, `start_date='2024-12-01'`, `end_date='2024-12-31'`, `from_time='10:00'`, `to_time='22:00'`

---

### 25. Reviews
**Purpose**: Customer reviews and ratings (future feature)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique review identifier |
| customer_id | UUID | FOREIGN KEY â†’ customers.id, NULLABLE | Customer (if provided ID/phone) |
| order_id | UUID | FOREIGN KEY â†’ orders.id, NULLABLE | Related order |
| menu_item_id | UUID | FOREIGN KEY â†’ menu_items.id, NULLABLE | Item being reviewed |
| rating | INTEGER | NOT NULL | Rating (1-5 stars) |
| comment | TEXT | NULLABLE | Review comment |
| is_moderated | BOOLEAN | NOT NULL, DEFAULT false | Whether review has been moderated |
| is_approved | BOOLEAN | NULLABLE | Whether review was approved |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Review timestamp |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

---

## Entity Relationships Summary

### Primary Relationships:
- **Tables** â†’ **Orders** (one-to-many)
- **Customers** â†’ **Orders** (one-to-many, optional)
- **Orders** â†’ **Order Items** (one-to-many)
- **Order Items** â†’ **Menu Items** (many-to-one)
- **Menu Items** â†’ **Menu Categories** (many-to-one)
- **Menu Items** â†’ **Menu Item Stock Items** (one-to-many)
- **Stock Items** â†’ **Menu Item Stock Items** (one-to-many)
- **Stock Items** â†’ **Stock Item Categories** (many-to-one)
- **Stock Items** â†’ **Existences** (one-to-many)
- **Suppliers** â†’ **Invoices** (one-to-many)
- **Invoices** â†’ **Invoice Details** (one-to-many)
- **Invoice Details** â†’ **Existences** (one-to-many)
- **Customers** â†’ **Customer Favorites** (one-to-many)
- **Menu Items** â†’ **Customer Favorites** (one-to-many)
- **Orders** â†’ **Promotions** (many-to-one, optional)
- **Orders** â†’ **Payments** (one-to-many)
- **Orders** â†’ **Invoices** (one-to-one) - Note: This is for customer invoices (receipts), not purchase invoices
- **Payments** â†’ **Invoices** (one-to-one, optional) - Note: Customer invoices/receipts
- **Promotions** â†’ **Orders** (one-to-many) - Promotions can be applied to multiple orders
- **Customers** â†’ **Loyalty Points Transactions** (one-to-many)
- **Orders** â†’ **Loyalty Points Transactions** (one-to-many) - Orders can generate multiple point transactions (earned/spent)
- **Tables** â†’ **Request Notifications** (one-to-many)
- **Tables** â†’ **Karaoke Song Requests** (one-to-many)
- **Tables** â†’ **Table Sessions** (one-to-many, active session only)

### Foreign Key Constraints:
- All foreign keys should have appropriate CASCADE or RESTRICT rules
- Consider soft deletes for important entities (add `deleted_at` timestamp)

---

## Indexes Recommendations

### Performance Indexes:
- `customers.customer_id` (UNIQUE)
- `customers.phone` (for lookup)
- `orders.table_id` + `orders.status`
- `orders.customer_id` (for customer history)
- `order_items.order_id` + `order_items.status`
- `order_items.menu_item_id`
- `payments.order_id`
- `request_notifications.table_id` + `request_notifications.status`
- `request_notifications.request_type` + `request_notifications.status`
- `karaoke_song_requests.status` + `karaoke_song_requests.position_in_queue`
- `menu_items.is_available` + `menu_items.menu_types`
- `table_sessions.table_id` + `table_sessions.status`

---

## Notes

- All timestamps should use UTC timezone
- All monetary values use DECIMAL(10,2) for precision
- UUIDs are used for all primary keys for security and scalability
- JSON fields are used for flexible data structures (dietary_tags, allergens, menu_types)
- Enum types should be defined at database level for data integrity
- Consider adding `deleted_at` timestamp for soft deletes on important entities
- Audit fields (`created_at`, `updated_at`) should be automatically managed

---

**Last Updated:** 2024-12-19
**Status:** Planning Phase
