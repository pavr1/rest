# This are the rules the AI must follow to generate custom applications:

## Language
Golang

## Reference
Base off of /Users/pvillalobos/Documents/poc/local to follow the structure

Below you can see a structure chart of how local works, we need to follow the same patterns.

```
â”œâ”€â”€ ðŸ“‹ Root Level (Orchestration)
â”‚   â”œâ”€â”€ Makefile              # Root orchestration for all services
â”‚   â”œâ”€â”€ README.md             # System overview & documentation
â”‚   â”œâ”€â”€ LOCAL-DEVELOPMENT.md  # Local dev setup guide
â”‚   â”œâ”€â”€ start-local.sh        # Start all services locally
â”‚   â””â”€â”€ stop-local.sh         # Stop all services
â”‚
â”œâ”€â”€ ðŸ”§ Shared Components
â”‚   â””â”€â”€ shared/
â”‚       â”œâ”€â”€ config/           # Centralized config loader (fetches from data-service)
â”‚       â”œâ”€â”€ logger/          # Shared logging utilities
â”‚       â”œâ”€â”€ middlewares/     # Gateway & RequestID middleware
â”‚       â””â”€â”€ models/          # Shared data models
â”‚
â”œâ”€â”€ ðŸ—„ï¸ Data Service (Foundation)
â”‚   â””â”€â”€ data-service/
â”‚       â”œâ”€â”€ docker/          # PostgreSQL + PgAdmin containers
â”‚       â””â”€â”€ sql/             # Database schemas & migrations
â”‚
â”œâ”€â”€ ðŸ” Session Service (Authentication)
â”‚   â””â”€â”€ session-service/
â”‚       â”œâ”€â”€ main.go
â”‚       â””â”€â”€ sql/             # Session management queries
â”‚
â”œâ”€â”€ ðŸŒ Gateway Service (API Gateway)
â”‚   â””â”€â”€ gateway-service/
â”‚       â”œâ”€â”€ main.go          # Reverse proxy + routing
â”‚       â”œâ”€â”€ middleware/      # CORS, Session validation
â”‚       â””â”€â”€ docs/            # Architecture documentation
â”‚
â”œâ”€â”€ ðŸ“¦ Business Services (Domain-Specific)
â”‚   â”œâ”€â”€ orders-service/
â”‚   â”‚   â”œâ”€â”€ main.go
â”‚   â”‚   â”œâ”€â”€ handler/         # HTTP + DB handlers
â”‚   â”‚   â”œâ”€â”€ models/          # Domain models
â”‚   â”‚   â””â”€â”€ sql/            # SQL queries & scripts
â”‚   â”‚
â”‚   â”œâ”€â”€ inventory-service/
â”‚   â”‚   â”œâ”€â”€ main.go
â”‚   â”‚   â””â”€â”€ entities/       # Domain entities (DDD pattern)
â”‚   â”‚       â”œâ”€â”€ suppliers/
â”‚   â”‚       â”œâ”€â”€ ingredients/
â”‚   â”‚       â”œâ”€â”€ recipes/
â”‚   â”‚       â”œâ”€â”€ existences/
â”‚   â”‚       â””â”€â”€ [each entity has:]
â”‚   â”‚           â”œâ”€â”€ handlers/  # HTTP + DB handlers
â”‚   â”‚           â”œâ”€â”€ models/    # Domain models
â”‚   â”‚           â””â”€â”€ sql/       # Queries & scripts
â”‚   â”‚
â”‚   â””â”€â”€ invoice-service/
â”‚       â”œâ”€â”€ main.go
â”‚       â””â”€â”€ entities/        # Similar entity structure
â”‚           â”œâ”€â”€ invoices/
â”‚           â””â”€â”€ expense_categories/
â”‚
â””â”€â”€ ðŸŽ¨ UI Service
    â””â”€â”€ ui/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ dashboard.html
        â””â”€â”€ partials/        # Modular HTML components
```

## Layouts
The application must have the following layers:
- DB (postgres)
- Server (http)
- Client (html)

## Server Structure
The server layout must follow the bellow structure:

REST
    REST will be the workspace where all services will be stored within. Each service will be created here as a standalone service. i.e: inventory_service, payment_service, etc.
    
    - storage: The first service to be created is storage_service which will handle all db-related connections. All the services must be connected and pinging storage_service to function.

    - internals: ** TBD: Need to plan all the services that will be created here.

    - gateway: This will be the point of comunication between the ui and the internal services. Gateway will be in charge of user authentication and authorization using jwt token. Besides injecting metadata avoind direct connection to internal services.

    - ui: this service will handle all the pages and user interface content, using html and bootstrap.

    ### Structure
    ui -> gateway -> internal services -> storage

## Environment setup.
Base on the local project, we need to use docker, docker-compose and kubernetes setup. We have colima installed so we can set it up and work it locally with that.

## Makefile Standards

**Each service's Makefile must contain Docker-related commands and test commands only.**

Do NOT include:
- `build` (Go build commands)
- `run` (direct Go run)
- `deps` (Go mod commands)

DO include:
- `start` - Start Docker containers
- `stop` - Stop Docker containers
- `restart` - Restart containers
- `logs` - View container logs
- `status` - Show container status
- `clean` - Remove containers/volumes
- `test` - Run tests
- `help` - Show available commands

Example Makefile structure:
```makefile
.PHONY: start stop restart logs status clean test help
.DEFAULT_GOAL := help

start: _network
	@cd docker && docker-compose up -d

stop:
	@cd docker && docker-compose down

restart: stop start

logs:
	@cd docker && docker-compose logs -f

status:
	@cd docker && docker-compose ps

clean:
	@cd docker && docker-compose down -v

test:
	@go test -v ./...

help:
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST)

_network:
	@docker network create docker_barrest_network 2>/dev/null || true
```

This ensures consistent Docker-based development across all services.

## Global Makefile

**When creating a new service, the root `Makefile` MUST be updated to include it.**

The global Makefile at `/rest/Makefile` orchestrates all services. For each new service:

1. Add a `test-{service}` target
2. Include the service in the `test` target (runs all tests)
3. Include the service in `start`, `stop`, `status`, `clean`, and `fresh` targets

Example additions for a new `orders-service`:

```makefile
# Add new test target
test-orders: ## Run orders-service tests only
	@cd orders-service && go test -v ./...

# Update the main test target to include it
test:
	@cd data-service && go test -v ./...
	@cd session-service && go test -v ./...
	@cd orders-service && go test -v ./...  # Add this line

# Update start/stop targets
start:
	@cd data-service && make start
	@cd session-service && make start
	@cd orders-service && make start  # Add this line
```

**Checklist when adding a new service:**
- [ ] Create service directory with Makefile following standards
- [ ] Add `test-{service}` target to root Makefile
- [ ] Add service to `test` target
- [ ] Add service to `start` target
- [ ] Add service to `stop` target
- [ ] Add service to `status` target
- [ ] Add service to `clean` target
- [ ] Add service to `fresh` target

## Docker Healthcheck Standards

**Every service container MUST have a healthcheck configured.**

### Healthcheck Configuration

All services must follow this healthcheck pattern in their `docker-compose.yml`:

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:{PORT}/api/v1/{service}/p/health"]
  interval: 1s
  timeout: 5s
  retries: 3
  start_period: 10s
```

### Health Endpoint Requirements

Each service must expose a health endpoint at:
```
GET /api/v1/{service}/p/health
```

Examples:
- data-service: `/api/v1/data/p/health`
- session-service: `/api/v1/sessions/p/health`
- orders-service: `/api/v1/orders/p/health`

### Health Dependency Chain

Services must check their dependencies' health in their health endpoint:

```
postgres (pg_isready)
    â†“
data-service (checks postgres via DB query)
    â†“
session-service (checks data-service health endpoint)
    â†“
other services (check their dependencies)
```

**If a dependency is unhealthy, the service must return `503 Service Unavailable`.**

### Docker Compose Dependencies

Use `depends_on` with `condition: service_healthy` for startup ordering:

```yaml
services:
  my-service:
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8087/api/v1/myservice/p/health"]
      interval: 1s
      timeout: 5s
      retries: 3
      start_period: 10s
```

### Dockerfile Requirements

The runtime image must include `curl` for healthchecks:

```dockerfile
FROM alpine:latest
RUN apk --no-cache add ca-certificates curl
```

### Healthcheck Values

| Parameter | Value | Description |
|-----------|-------|-------------|
| `interval` | `1s` | How often to check |
| `timeout` | `5s` | Max time for check to complete |
| `retries` | `3` | Failures before unhealthy |
| `start_period` | `10s` | Grace period at startup (can be adjusted per service) |

### Health Response Format

Healthy response (200 OK):
```json
{
  "code": 200,
  "message": "Service healthy",
  "data": {
    "status": "healthy",
    "service": "service-name"
  }
}
```

Unhealthy response (503 Service Unavailable):
```json
{
  "code": 503,
  "message": "Dependency unhealthy",
  "error": "Data-service is not healthy"
}
```

